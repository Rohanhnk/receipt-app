export declare type BooleanListenerFn = (value: boolean) => void;

/**
 *
 * @export
 * @interface CheckFlagResponse
 */
declare interface CheckFlagResponse {
    /**
     *
     * @type {CheckFlagResponseData}
     * @memberof CheckFlagResponse
     */
    data: CheckFlagResponseData;
    /**
     * Input parameters
     * @type {object}
     * @memberof CheckFlagResponse
     */
    params: object;
}

/**
 * Schematic API
 * Schematic API
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface CheckFlagResponseData
 */
export declare interface CheckFlagResponseData {
    /**
     * If company keys were provided and matched a company, its ID
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    companyId?: string | null;
    /**
     * If an error occurred while checking the flag, the error message
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    error?: string | null;
    /**
     * If a numeric feature entitlement rule was matched, its allocation
     * @type {number}
     * @memberof CheckFlagResponseData
     */
    featureAllocation?: number | null;
    /**
     * If a numeric feature entitlement rule was matched, the company's usage
     * @type {number}
     * @memberof CheckFlagResponseData
     */
    featureUsage?: number | null;
    /**
     * If an event-based numeric feature entitlement rule was matched, the event used to track its usage
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    featureUsageEvent?: string | null;
    /**
     * For event-based feature entitlement rules, the period over which usage is tracked (current_month, current_day, current_week, all_time)
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    featureUsagePeriod?: string | null;
    /**
     * For event-based feature entitlement rules, when the usage period will reset
     * @type {Date}
     * @memberof CheckFlagResponseData
     */
    featureUsageResetAt?: Date | null;
    /**
     * The key used to check the flag
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    flag: string;
    /**
     * If a flag was found, its ID
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    flagId?: string | null;
    /**
     * A human-readable explanation of the result
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    reason: string;
    /**
     * If a rule was found, its ID
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    ruleId?: string | null;
    /**
     * If a rule was found, its type
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    ruleType?: string | null;
    /**
     * If user keys were provided and matched a user, its ID
     * @type {string}
     * @memberof CheckFlagResponseData
     */
    userId?: string | null;
    /**
     * A boolean flag check result; for feature entitlements, this represents whether further consumption of the feature is permitted
     * @type {boolean}
     * @memberof CheckFlagResponseData
     */
    value: boolean;
}

export declare function CheckFlagResponseFromJSON(json: any): CheckFlagResponse;

export declare type CheckFlagReturn = {
    /** The company has access to the feature, but has exceeded the usage limit */
    featureUsageExceeded?: boolean;
    /** If company keys were provided and matched a company, its ID */
    companyId?: string;
    /** If an error occurred while checking the flag, the error message */
    error?: string;
    /** If a numeric feature entitlement rule was matched, its allocation */
    featureAllocation?: number;
    /** If a numeric feature entitlement rule was matched, the company's usage */
    featureUsage?: number;
    /** Event representing the feature usage */
    featureUsageEvent?: string;
    /** For event-based feature entitlement rules, the period over which usage is tracked (current_month, current_day, current_week, all_time) */
    featureUsagePeriod?: UsagePeriod;
    /** For event-based feature entitlement rules, when the usage period will reset */
    featureUsageResetAt?: Date;
    /** The key used to check the flag */
    flag: string;
    /** If a flag was found, its ID */
    flagId?: string;
    /** A human-readable explanation of the result */
    reason: string;
    /** If a rule was found, its ID */
    ruleId?: string;
    /** If a rule was found, its type  */
    ruleType?: RuleType;
    /** If user keys were provided and matched a user, its ID */
    userId?: string;
    /** A boolean flag check result; for feature entitlements, this represents whether further consumption of the feature is permitted */
    value: boolean;
};

export declare const CheckFlagReturnFromJSON: (json: any) => CheckFlagReturn;

export declare type CheckFlagReturnListenerFn = (value: CheckFlagReturn) => void;

/**
 *
 * @export
 * @interface CheckFlagsResponse
 */
declare interface CheckFlagsResponse {
    /**
     *
     * @type {CheckFlagsResponseData}
     * @memberof CheckFlagsResponse
     */
    data: CheckFlagsResponseData;
    /**
     * Input parameters
     * @type {object}
     * @memberof CheckFlagsResponse
     */
    params: object;
}

/**
 *
 * @export
 * @interface CheckFlagsResponseData
 */
declare interface CheckFlagsResponseData {
    /**
     *
     * @type {Array<CheckFlagResponseData>}
     * @memberof CheckFlagsResponseData
     */
    flags: Array<CheckFlagResponseData>;
}

export declare function CheckFlagsResponseFromJSON(json: any): CheckFlagsResponse;

export declare type CheckOptions = {
    context?: SchematicContext;
    fallback?: boolean;
    key: string;
};

export declare type EmptyListenerFn = () => void;

declare type Event_2 = {
    api_key: string;
    body: EventBody;
    sent_at: string;
    tracker_event_id: string;
    tracker_user_id: string;
    type: EventType;
};
export { Event_2 as Event }

export declare type EventBody = EventBodyIdentify | EventBodyTrack | EventBodyFlagCheck;

/**
 * Schematic API
 * Schematic API
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 * @interface EventBodyFlagCheck
 */
export declare interface EventBodyFlagCheck {
    /**
     * Schematic company ID (starting with 'comp_') of the company evaluated, if any
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    companyId?: string | null;
    /**
     * Report an error that occurred during the flag check
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    error?: string | null;
    /**
     * Schematic flag ID (starting with 'flag_') for the flag matching the key, if any
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    flagId?: string | null;
    /**
     * The key of the flag being checked
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    flagKey: string;
    /**
     * The reason why the value was returned
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    reason: string;
    /**
     * Key-value pairs used to to identify company for which the flag was checked
     * @type {{ [key: string]: string; }}
     * @memberof EventBodyFlagCheck
     */
    reqCompany?: {
        [key: string]: string;
    } | null;
    /**
     * Key-value pairs used to to identify user for which the flag was checked
     * @type {{ [key: string]: string; }}
     * @memberof EventBodyFlagCheck
     */
    reqUser?: {
        [key: string]: string;
    } | null;
    /**
     * Schematic rule ID (starting with 'rule_') of the rule that matched for the flag, if any
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    ruleId?: string | null;
    /**
     * Schematic user ID (starting with 'user_') of the user evaluated, if any
     * @type {string}
     * @memberof EventBodyFlagCheck
     */
    userId?: string | null;
    /**
     * The value of the flag for the given company and/or user
     * @type {boolean}
     * @memberof EventBodyFlagCheck
     */
    value: boolean;
}

export declare function EventBodyFlagCheckToJSON(json: any): EventBodyFlagCheck;

export declare type EventBodyIdentify = {
    company?: {
        keys?: Keys;
        name?: string;
        traits?: Traits;
    };
    keys?: Keys;
    name?: string;
    traits?: Traits;
};

export declare type EventBodyTrack = SchematicContext & {
    event: string;
    quantity?: number;
    traits?: Traits;
};

export declare type EventType = "identify" | "track" | "flag_check";

export declare type FlagCheckListenerFn = CheckFlagReturnListenerFn | EmptyListenerFn;

export declare type FlagValueListenerFn = BooleanListenerFn | EmptyListenerFn;

/** A record of unique key-value pairs used for identifying a company or user */
export declare type Keys = Record<string, string>;

export declare type PendingListenerFn = BooleanListenerFn | EmptyListenerFn;

export declare enum RuleType {
    /** A global rule that, if present, will override all other rules for a flag */
    GLOBAL_OVERRIDE = "global_override",
    /** Rule type indicating feature access provisioned to a company via an override */
    COMPANY_OVERRIDE = "company_override",
    /** Rule type indicating that feature access has been provisione to a company via an override, but the usage limit has been reached or exceeded */
    COMPANY_OVERRIDE_USAGE_EXCEEDED = "company_override_usage_exceeded",
    /** Rule type indicating feature access provisioned to a company via its base plan or add-ons */
    PLAN_ENTITLEMENT = "plan_entitlement",
    /** Rule type indicating that feature access has been provisione to a company via base plan or add-ons, but the usage limit has been reached or exceeded */
    PLAN_ENTITLEMENT_USAGE_EXCEEDED = "plan_entitlement_usage_exceeded",
    /** General-purpose targeting rule */
    STANDARD = "standard",
    /** Default rule type that will be used if no other rules are matched */
    DEFAULT = "default"
}

export declare class Schematic {
    private additionalHeaders;
    private apiKey;
    private apiUrl;
    private conn;
    private context;
    private debugEnabled;
    private offlineEnabled;
    private eventQueue;
    private contextDependentEventQueue;
    private eventUrl;
    private flagCheckListeners;
    private flagValueListeners;
    private isPending;
    private isPendingListeners;
    private storage;
    private useWebSocket;
    private checks;
    private featureUsageEventMap;
    private webSocketUrl;
    constructor(apiKey: string, options?: SchematicOptions);
    /**
     * Get value for a single flag.
     * In WebSocket mode, returns cached values if connection is active, otherwise establishes
     * new connection and then returns the requestedvalue. Falls back to REST API if WebSocket
     * connection fails.
     * In REST mode, makes an API call for each check.
     */
    checkFlag(options: CheckOptions): Promise<boolean>;
    /**
     * Helper function to log debug messages
     * Only logs if debug mode is enabled
     */
    private debug;
    /**
     * Helper function to check if client is in offline mode
     */
    private isOffline;
    /**
     * Submit a flag check event
     * Records data about a flag check for analytics
     */
    private submitFlagCheckEvent;
    /**
     * Helper method for falling back to REST API when WebSocket connection fails
     */
    private fallbackToRest;
    /**
     * Make an API call to fetch all flag values for a given context.
     * Recommended for use in REST mode only.
     * In offline mode, returns an empty object.
     */
    checkFlags: (context?: SchematicContext) => Promise<Record<string, boolean>>;
    /**
     * Send an identify event.
     * This will set the context for subsequent flag evaluation and events, and will also
     * send an identify event to the Schematic API which will upsert a user and company.
     */
    identify: (body: EventBodyIdentify) => Promise<void>;
    /**
     * Set the flag evaluation context.
     * In WebSocket mode, this will:
     * 1. Open a websocket connection if not already open
     * 2. Send the context to the server
     * 3. Wait for initial flag values to be returned
     * The promise resolves when initial flag values are received.
     * In offline mode, this will just set the context locally without connecting.
     */
    setContext: (context: SchematicContext) => Promise<void>;
    /**
     * Send a track event
     * Track usage for a company and/or user.
     * Optimistically updates feature usage flags if tracking a featureUsageEvent.
     */
    track: (body: EventBodyTrack) => Promise<void>;
    /**
     * Optimistically update feature usage flags associated with a tracked event
     * This updates flags in memory with updated usage counts and value/featureUsageExceeded flags
     * before the network request completes
     */
    private optimisticallyUpdateFeatureUsage;
    /**
     * Event processing
     */
    private hasContext;
    private flushContextDependentEventQueue;
    private flushEventQueue;
    private getAnonymousId;
    private handleEvent;
    private sendEvent;
    private storeEvent;
    /**
     * Websocket management
     */
    /**
     * If using websocket mode, close the connection when done.
     * In offline mode, this is a no-op.
     */
    cleanup: () => Promise<void>;
    private wsConnect;
    private wsSendMessage;
    /**
     * State management
     */
    getIsPending: () => boolean;
    addIsPendingListener: (listener: PendingListenerFn) => () => void;
    private setIsPending;
    getFlagCheck: (flagKey: string) => CheckFlagReturn | undefined;
    getFlagValue: (flagKey: string) => boolean | undefined;
    /** Register an event listener that will be notified with the boolean value for a given flag when this value changes */
    addFlagValueListener: (flagKey: string, listener: FlagValueListenerFn) => () => void;
    /** Register an event listener that will be notified with the full flag check response for a given flag whenever this value changes */
    addFlagCheckListener: (flagKey: string, listener: FlagCheckListenerFn) => () => void;
    private notifyFlagCheckListeners;
    /** Add or update a CheckFlagReturn in the featureUsageEventMap */
    private updateFeatureUsageEventMap;
    private notifyFlagValueListeners;
}

/** Context for checking flags and sending events */
export declare type SchematicContext = {
    company?: Keys;
    user?: Keys;
};

export declare type SchematicOptions = {
    /** Optionally provide any additional headers to include in the request */
    additionalHeaders?: Record<string, string>;
    /** Optionally provide a custom API URL */
    apiUrl?: string;
    /** Enable debug mode to log flag check results and events to the console.
     * Can also be enabled at runtime via URL query parameter "schematic_debug=true" */
    debug?: boolean;
    /** Optionally provide a custom event URL */
    eventUrl?: string;
    /** Enable offline mode to prevent all network requests.
     * When enabled, events are only logged not sent, and flag checks return fallback values.
     * Can also be enabled at runtime via URL query parameter "schematic_offline=true" */
    offline?: boolean;
    /** Optionally provide a custom storage persister for client-side storage */
    storage?: StoragePersister;
    /** Use a WebSocket connection for real-time flag checks; if using this, run the cleanup function to close the connection */
    useWebSocket?: boolean;
    /** Optionally provide a custom WebSocket URL */
    webSocketUrl?: string;
};

/** Optional type for implementing custom client-side storage */
export declare type StoragePersister = {
    setItem(key: string, value: any): void;
    getItem(key: string): any;
    removeItem(key: string): void;
};

/**
 * A flexible key/value type that can store any type of value on a company or user.
 */
export declare type Traits = Record<string, any>;

export declare enum UsagePeriod {
    ALL_TIME = "all_time",
    CURRENT_DAY = "current_day",
    CURRENT_MONTH = "current_month",
    CURRENT_WEEK = "current_week"
}

export { }
