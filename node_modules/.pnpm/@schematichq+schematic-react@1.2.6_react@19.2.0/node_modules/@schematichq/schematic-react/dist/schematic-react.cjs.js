"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  RuleType: () => RuleType,
  Schematic: () => Schematic,
  SchematicProvider: () => SchematicProvider,
  UsagePeriod: () => UsagePeriod,
  useSchematic: () => useSchematic,
  useSchematicContext: () => useSchematicContext,
  useSchematicEntitlement: () => useSchematicEntitlement,
  useSchematicEvents: () => useSchematicEvents,
  useSchematicFlag: () => useSchematicFlag,
  useSchematicIsPending: () => useSchematicIsPending
});
module.exports = __toCommonJS(index_exports);

// node_modules/@schematichq/schematic-js/dist/schematic.esm.js
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_browser_polyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-polyfill.js"(exports) {
    (function(self2) {
      var irrelevant = (function(exports2) {
        var g = typeof globalThis !== "undefined" && globalThis || typeof self2 !== "undefined" && self2 || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && (function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          })(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || (function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          })();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch2;
          g.Headers = Headers;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        return exports2;
      })({});
    })(typeof self !== "undefined" ? self : exports);
  }
});
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };
function _v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;
var import_polyfill = __toESM2(require_browser_polyfill());
function CheckFlagResponseDataFromJSON(json) {
  return CheckFlagResponseDataFromJSONTyped(json, false);
}
function CheckFlagResponseDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    companyId: json["company_id"] == null ? void 0 : json["company_id"],
    error: json["error"] == null ? void 0 : json["error"],
    featureAllocation: json["feature_allocation"] == null ? void 0 : json["feature_allocation"],
    featureUsage: json["feature_usage"] == null ? void 0 : json["feature_usage"],
    featureUsageEvent: json["feature_usage_event"] == null ? void 0 : json["feature_usage_event"],
    featureUsagePeriod: json["feature_usage_period"] == null ? void 0 : json["feature_usage_period"],
    featureUsageResetAt: json["feature_usage_reset_at"] == null ? void 0 : new Date(json["feature_usage_reset_at"]),
    flag: json["flag"],
    flagId: json["flag_id"] == null ? void 0 : json["flag_id"],
    reason: json["reason"],
    ruleId: json["rule_id"] == null ? void 0 : json["rule_id"],
    ruleType: json["rule_type"] == null ? void 0 : json["rule_type"],
    userId: json["user_id"] == null ? void 0 : json["user_id"],
    value: json["value"]
  };
}
function EventBodyFlagCheckToJSON(json) {
  return EventBodyFlagCheckToJSONTyped(json, false);
}
function EventBodyFlagCheckToJSONTyped(value, ignoreDiscriminator = false) {
  if (value == null) {
    return value;
  }
  return {
    company_id: value["companyId"],
    error: value["error"],
    flag_id: value["flagId"],
    flag_key: value["flagKey"],
    reason: value["reason"],
    req_company: value["reqCompany"],
    req_user: value["reqUser"],
    rule_id: value["ruleId"],
    user_id: value["userId"],
    value: value["value"]
  };
}
function CheckFlagResponseFromJSON(json) {
  return CheckFlagResponseFromJSONTyped(json, false);
}
function CheckFlagResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    data: CheckFlagResponseDataFromJSON(json["data"]),
    params: json["params"]
  };
}
function CheckFlagsResponseDataFromJSON(json) {
  return CheckFlagsResponseDataFromJSONTyped(json, false);
}
function CheckFlagsResponseDataFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    flags: json["flags"].map(CheckFlagResponseDataFromJSON)
  };
}
function CheckFlagsResponseFromJSON(json) {
  return CheckFlagsResponseFromJSONTyped(json, false);
}
function CheckFlagsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json == null) {
    return json;
  }
  return {
    data: CheckFlagsResponseDataFromJSON(json["data"]),
    params: json["params"]
  };
}
var RuleType = /* @__PURE__ */ ((RuleType2) => {
  RuleType2["GLOBAL_OVERRIDE"] = "global_override";
  RuleType2["COMPANY_OVERRIDE"] = "company_override";
  RuleType2["COMPANY_OVERRIDE_USAGE_EXCEEDED"] = "company_override_usage_exceeded";
  RuleType2["PLAN_ENTITLEMENT"] = "plan_entitlement";
  RuleType2["PLAN_ENTITLEMENT_USAGE_EXCEEDED"] = "plan_entitlement_usage_exceeded";
  RuleType2["STANDARD"] = "standard";
  RuleType2["DEFAULT"] = "default";
  return RuleType2;
})(RuleType || {});
var UsagePeriod = /* @__PURE__ */ ((UsagePeriod2) => {
  UsagePeriod2["ALL_TIME"] = "all_time";
  UsagePeriod2["CURRENT_DAY"] = "current_day";
  UsagePeriod2["CURRENT_MONTH"] = "current_month";
  UsagePeriod2["CURRENT_WEEK"] = "current_week";
  return UsagePeriod2;
})(UsagePeriod || {});
var CheckFlagReturnFromJSON = (json) => {
  const {
    companyId,
    error,
    featureAllocation,
    featureUsage,
    featureUsageEvent,
    featureUsagePeriod,
    featureUsageResetAt,
    flag,
    flagId,
    reason,
    ruleId,
    ruleType,
    userId,
    value
  } = CheckFlagResponseDataFromJSON(json);
  const featureUsageExceeded = !value && // if flag is not false, then we haven't exceeded usage
  (ruleType == "company_override_usage_exceeded" || // if the rule type is one of these, then we have exceeded usage
  ruleType == "plan_entitlement_usage_exceeded");
  return {
    featureUsageExceeded,
    companyId: companyId == null ? void 0 : companyId,
    error: error == null ? void 0 : error,
    featureAllocation: featureAllocation == null ? void 0 : featureAllocation,
    featureUsage: featureUsage == null ? void 0 : featureUsage,
    featureUsageEvent: featureUsageEvent === null ? void 0 : featureUsageEvent,
    featureUsagePeriod: featureUsagePeriod == null ? void 0 : featureUsagePeriod,
    featureUsageResetAt: featureUsageResetAt == null ? void 0 : featureUsageResetAt,
    flag,
    flagId: flagId == null ? void 0 : flagId,
    reason,
    ruleId: ruleId == null ? void 0 : ruleId,
    ruleType: ruleType == null ? void 0 : ruleType,
    userId: userId == null ? void 0 : userId,
    value
  };
};
function contextString(context) {
  const sortedContext = Object.keys(context).reduce((acc, key) => {
    const sortedKeys = Object.keys(
      context[key] || {}
    ).sort();
    const sortedObj = sortedKeys.reduce((obj, sortedKey) => {
      obj[sortedKey] = context[key][sortedKey];
      return obj;
    }, {});
    acc[key] = sortedObj;
    return acc;
  }, {});
  return JSON.stringify(sortedContext);
}
var version = "1.2.6";
var anonymousIdKey = "schematicId";
var Schematic = class {
  additionalHeaders = {};
  apiKey;
  apiUrl = "https://api.schematichq.com";
  conn = null;
  context = {};
  debugEnabled = false;
  offlineEnabled = false;
  eventQueue;
  contextDependentEventQueue;
  eventUrl = "https://c.schematichq.com";
  flagCheckListeners = {};
  flagValueListeners = {};
  isPending = true;
  isPendingListeners = /* @__PURE__ */ new Set();
  storage;
  useWebSocket = false;
  checks = {};
  featureUsageEventMap = {};
  webSocketUrl = "wss://api.schematichq.com";
  constructor(apiKey, options) {
    this.apiKey = apiKey;
    this.eventQueue = [];
    this.contextDependentEventQueue = [];
    this.useWebSocket = options?.useWebSocket ?? false;
    this.debugEnabled = options?.debug ?? false;
    this.offlineEnabled = options?.offline ?? false;
    if (typeof window !== "undefined" && typeof window.location !== "undefined") {
      const params = new URLSearchParams(window.location.search);
      const debugParam = params.get("schematic_debug");
      if (debugParam !== null && (debugParam === "" || debugParam === "true" || debugParam === "1")) {
        this.debugEnabled = true;
      }
      const offlineParam = params.get("schematic_offline");
      if (offlineParam !== null && (offlineParam === "" || offlineParam === "true" || offlineParam === "1")) {
        this.offlineEnabled = true;
        this.debugEnabled = true;
      }
    }
    if (this.offlineEnabled && options?.debug !== false) {
      this.debugEnabled = true;
    }
    if (this.offlineEnabled) {
      this.setIsPending(false);
    }
    this.additionalHeaders = {
      "X-Schematic-Client-Version": `schematic-js@${version}`,
      ...options?.additionalHeaders ?? {}
    };
    if (options?.storage) {
      this.storage = options.storage;
    } else if (typeof localStorage !== "undefined") {
      this.storage = localStorage;
    }
    if (options?.apiUrl !== void 0) {
      this.apiUrl = options.apiUrl;
    }
    if (options?.eventUrl !== void 0) {
      this.eventUrl = options.eventUrl;
    }
    if (options?.webSocketUrl !== void 0) {
      this.webSocketUrl = options.webSocketUrl;
    }
    if (typeof window !== "undefined" && window?.addEventListener) {
      window.addEventListener("beforeunload", () => {
        this.flushEventQueue();
        this.flushContextDependentEventQueue();
      });
    }
    if (this.offlineEnabled) {
      this.debug(
        "Initialized with offline mode enabled - no network requests will be made"
      );
    } else if (this.debugEnabled) {
      this.debug("Initialized with debug mode enabled");
    }
  }
  /**
   * Get value for a single flag.
   * In WebSocket mode, returns cached values if connection is active, otherwise establishes
   * new connection and then returns the requestedvalue. Falls back to REST API if WebSocket
   * connection fails.
   * In REST mode, makes an API call for each check.
   */
  async checkFlag(options) {
    const { fallback = false, key } = options;
    const context = options.context || this.context;
    const contextStr = contextString(context);
    this.debug(`checkFlag: ${key}`, { context, fallback });
    if (this.isOffline()) {
      this.debug(`checkFlag offline result: ${key}`, {
        value: fallback,
        offlineMode: true
      });
      return fallback;
    }
    if (!this.useWebSocket) {
      const requestUrl = `${this.apiUrl}/flags/${key}/check`;
      return fetch(requestUrl, {
        method: "POST",
        headers: {
          ...this.additionalHeaders ?? {},
          "Content-Type": "application/json;charset=UTF-8",
          "X-Schematic-Api-Key": this.apiKey
        },
        body: JSON.stringify(context)
      }).then((response) => {
        if (!response.ok) {
          throw new Error("Network response was not ok");
        }
        return response.json();
      }).then((response) => {
        const parsedResponse = CheckFlagResponseFromJSON(response);
        this.debug(`checkFlag result: ${key}`, parsedResponse);
        const result = CheckFlagReturnFromJSON(parsedResponse.data);
        if (typeof result.featureUsageEvent === "string") {
          this.updateFeatureUsageEventMap(result);
        }
        this.submitFlagCheckEvent(key, result, context);
        return result.value;
      }).catch((error) => {
        console.error("There was a problem with the fetch operation:", error);
        const errorResult = {
          flag: key,
          value: fallback,
          reason: "API request failed",
          error: error instanceof Error ? error.message : String(error)
        };
        this.submitFlagCheckEvent(key, errorResult, context);
        return fallback;
      });
    }
    try {
      const existingVals = this.checks[contextStr];
      if (this.conn !== null && typeof existingVals !== "undefined" && typeof existingVals[key] !== "undefined") {
        this.debug(`checkFlag cached result: ${key}`, existingVals[key]);
        return existingVals[key].value;
      }
      if (this.isOffline()) {
        return fallback;
      }
      try {
        await this.setContext(context);
      } catch (error) {
        console.error(
          "WebSocket connection failed, falling back to REST:",
          error
        );
        return this.fallbackToRest(key, context, fallback);
      }
      const contextVals = this.checks[contextStr] ?? {};
      const flagCheck = contextVals[key];
      const result = flagCheck?.value ?? fallback;
      this.debug(
        `checkFlag WebSocket result: ${key}`,
        typeof flagCheck !== "undefined" ? flagCheck : { value: fallback, fallbackUsed: true }
      );
      if (typeof flagCheck !== "undefined") {
        this.submitFlagCheckEvent(key, flagCheck, context);
      }
      return result;
    } catch (error) {
      console.error("Unexpected error in checkFlag:", error);
      const errorResult = {
        flag: key,
        value: fallback,
        reason: "Unexpected error in flag check",
        error: error instanceof Error ? error.message : String(error)
      };
      this.submitFlagCheckEvent(key, errorResult, context);
      return fallback;
    }
  }
  /**
   * Helper function to log debug messages
   * Only logs if debug mode is enabled
   */
  debug(message, ...args) {
    if (this.debugEnabled) {
      console.log(`[Schematic] ${message}`, ...args);
    }
  }
  /**
   * Helper function to check if client is in offline mode
   */
  isOffline() {
    return this.offlineEnabled;
  }
  /**
   * Submit a flag check event
   * Records data about a flag check for analytics
   */
  submitFlagCheckEvent(flagKey, result, context) {
    const eventBody = {
      flagKey,
      value: result.value,
      reason: result.reason,
      flagId: result.flagId,
      ruleId: result.ruleId,
      companyId: result.companyId,
      userId: result.userId,
      error: result.error,
      reqCompany: context.company,
      reqUser: context.user
    };
    this.debug(`submitting flag check event:`, eventBody);
    return this.handleEvent("flag_check", EventBodyFlagCheckToJSON(eventBody));
  }
  /**
   * Helper method for falling back to REST API when WebSocket connection fails
   */
  async fallbackToRest(key, context, fallback) {
    if (this.isOffline()) {
      this.debug(`fallbackToRest offline result: ${key}`, {
        value: fallback,
        offlineMode: true
      });
      return fallback;
    }
    try {
      const requestUrl = `${this.apiUrl}/flags/${key}/check`;
      const response = await fetch(requestUrl, {
        method: "POST",
        headers: {
          ...this.additionalHeaders ?? {},
          "Content-Type": "application/json;charset=UTF-8",
          "X-Schematic-Api-Key": this.apiKey
        },
        body: JSON.stringify(context)
      });
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      const responseJson = await response.json();
      const data = CheckFlagResponseFromJSON(responseJson);
      this.debug(`fallbackToRest result: ${key}`, data);
      const result = CheckFlagReturnFromJSON(data.data);
      if (typeof result.featureUsageEvent === "string") {
        this.updateFeatureUsageEventMap(result);
      }
      this.submitFlagCheckEvent(key, result, context);
      return result.value;
    } catch (error) {
      console.error("REST API call failed, using fallback value:", error);
      const errorResult = {
        flag: key,
        value: fallback,
        reason: "API request failed (fallback)",
        error: error instanceof Error ? error.message : String(error)
      };
      this.submitFlagCheckEvent(key, errorResult, context);
      return fallback;
    }
  }
  /**
   * Make an API call to fetch all flag values for a given context.
   * Recommended for use in REST mode only.
   * In offline mode, returns an empty object.
   */
  checkFlags = async (context) => {
    context = context || this.context;
    this.debug(`checkFlags`, { context });
    if (this.isOffline()) {
      this.debug(`checkFlags offline result: returning empty object`);
      return {};
    }
    const requestUrl = `${this.apiUrl}/flags/check`;
    const requestBody = JSON.stringify(context);
    return fetch(requestUrl, {
      method: "POST",
      headers: {
        ...this.additionalHeaders ?? {},
        "Content-Type": "application/json;charset=UTF-8",
        "X-Schematic-Api-Key": this.apiKey
      },
      body: requestBody
    }).then((response) => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    }).then((responseJson) => {
      const resp = CheckFlagsResponseFromJSON(responseJson);
      this.debug(`checkFlags result:`, resp);
      return (resp?.data?.flags ?? []).reduce(
        (accum, flag) => {
          accum[flag.flag] = flag.value;
          return accum;
        },
        {}
      );
    }).catch((error) => {
      console.error("There was a problem with the fetch operation:", error);
      return {};
    });
  };
  /**
   * Send an identify event.
   * This will set the context for subsequent flag evaluation and events, and will also
   * send an identify event to the Schematic API which will upsert a user and company.
   */
  identify = (body) => {
    this.debug(`identify:`, body);
    try {
      this.setContext({
        company: body.company?.keys,
        user: body.keys
      });
    } catch (error) {
      console.error("Error setting context:", error);
    }
    return this.handleEvent("identify", body);
  };
  /**
   * Set the flag evaluation context.
   * In WebSocket mode, this will:
   * 1. Open a websocket connection if not already open
   * 2. Send the context to the server
   * 3. Wait for initial flag values to be returned
   * The promise resolves when initial flag values are received.
   * In offline mode, this will just set the context locally without connecting.
   */
  setContext = async (context) => {
    if (this.isOffline() || !this.useWebSocket) {
      this.context = context;
      this.flushContextDependentEventQueue();
      this.setIsPending(false);
      return Promise.resolve();
    }
    try {
      this.setIsPending(true);
      if (!this.conn) {
        this.conn = this.wsConnect();
      }
      const socket = await this.conn;
      await this.wsSendMessage(socket, context);
    } catch (error) {
      console.error("Failed to establish WebSocket connection:", error);
      throw error;
    }
  };
  /**
   * Send a track event
   * Track usage for a company and/or user.
   * Optimistically updates feature usage flags if tracking a featureUsageEvent.
   */
  track = (body) => {
    const { company, user, event, traits, quantity = 1 } = body;
    if (!this.hasContext(company, user)) {
      this.debug(`track: queuing event "${event}" until context is available`);
      const queuedEvent = {
        api_key: this.apiKey,
        body: {
          company,
          event,
          traits: traits ?? {},
          user,
          quantity
        },
        sent_at: (/* @__PURE__ */ new Date()).toISOString(),
        tracker_event_id: v4_default(),
        tracker_user_id: this.getAnonymousId(),
        type: "track"
      };
      this.contextDependentEventQueue.push(queuedEvent);
      return Promise.resolve();
    }
    const trackData = {
      company: company ?? this.context.company,
      event,
      traits: traits ?? {},
      user: user ?? this.context.user,
      quantity
    };
    this.debug(`track:`, trackData);
    if (event in this.featureUsageEventMap) {
      this.optimisticallyUpdateFeatureUsage(event, quantity);
    }
    return this.handleEvent("track", trackData);
  };
  /**
   * Optimistically update feature usage flags associated with a tracked event
   * This updates flags in memory with updated usage counts and value/featureUsageExceeded flags
   * before the network request completes
   */
  optimisticallyUpdateFeatureUsage = (eventName, quantity = 1) => {
    const flagsForEvent = this.featureUsageEventMap[eventName];
    if (flagsForEvent === void 0 || flagsForEvent === null) return;
    this.debug(
      `Optimistically updating feature usage for event: ${eventName}`,
      { quantity }
    );
    Object.entries(flagsForEvent).forEach(([flagKey, check]) => {
      if (check === void 0) return;
      const updatedCheck = { ...check };
      if (typeof updatedCheck.featureUsage === "number") {
        updatedCheck.featureUsage += quantity;
        if (typeof updatedCheck.featureAllocation === "number") {
          const wasExceeded = updatedCheck.featureUsageExceeded === true;
          const nowExceeded = updatedCheck.featureUsage >= updatedCheck.featureAllocation;
          if (nowExceeded !== wasExceeded) {
            updatedCheck.featureUsageExceeded = nowExceeded;
            if (nowExceeded) {
              updatedCheck.value = false;
            }
            this.debug(`Usage limit status changed for flag: ${flagKey}`, {
              was: wasExceeded ? "exceeded" : "within limits",
              now: nowExceeded ? "exceeded" : "within limits",
              featureUsage: updatedCheck.featureUsage,
              featureAllocation: updatedCheck.featureAllocation,
              value: updatedCheck.value
            });
          }
        }
        if (this.featureUsageEventMap[eventName] !== void 0) {
          this.featureUsageEventMap[eventName][flagKey] = updatedCheck;
        }
        const contextStr = contextString(this.context);
        if (this.checks[contextStr] !== void 0 && this.checks[contextStr] !== null) {
          this.checks[contextStr][flagKey] = updatedCheck;
        }
        this.notifyFlagCheckListeners(flagKey, updatedCheck);
        this.notifyFlagValueListeners(flagKey, updatedCheck.value);
      }
    });
  };
  /**
   * Event processing
   */
  hasContext = (company, user) => {
    const hasProvidedContext = company !== void 0 && company !== null && Object.keys(company).length > 0 || user !== void 0 && user !== null && Object.keys(user).length > 0;
    const hasInstanceContext = this.context.company !== void 0 && this.context.company !== null && Object.keys(this.context.company).length > 0 || this.context.user !== void 0 && this.context.user !== null && Object.keys(this.context.user).length > 0;
    return hasProvidedContext || hasInstanceContext;
  };
  flushContextDependentEventQueue = () => {
    this.debug(
      `flushing ${this.contextDependentEventQueue.length} context-dependent events`
    );
    while (this.contextDependentEventQueue.length > 0) {
      const event = this.contextDependentEventQueue.shift();
      if (event) {
        if (event.type === "track" && typeof event.body === "object" && event.body !== null) {
          const trackBody = event.body;
          const updatedBody = {
            ...trackBody,
            company: trackBody.company ?? this.context.company,
            user: trackBody.user ?? this.context.user
          };
          const updatedEvent = {
            ...event,
            body: updatedBody,
            sent_at: (/* @__PURE__ */ new Date()).toISOString()
            // Update timestamp to actual send time
          };
          this.sendEvent(updatedEvent);
        } else {
          this.sendEvent(event);
        }
      }
    }
  };
  flushEventQueue = () => {
    while (this.eventQueue.length > 0) {
      const event = this.eventQueue.shift();
      if (event) {
        this.sendEvent(event);
      }
    }
  };
  getAnonymousId = () => {
    if (!this.storage) {
      return v4_default();
    }
    const storedAnonymousId = this.storage.getItem(anonymousIdKey);
    if (typeof storedAnonymousId !== "undefined") {
      return storedAnonymousId;
    }
    const generatedAnonymousId = v4_default();
    this.storage.setItem(anonymousIdKey, generatedAnonymousId);
    return generatedAnonymousId;
  };
  handleEvent = (eventType, eventBody) => {
    const event = {
      api_key: this.apiKey,
      body: eventBody,
      sent_at: (/* @__PURE__ */ new Date()).toISOString(),
      tracker_event_id: v4_default(),
      tracker_user_id: this.getAnonymousId(),
      type: eventType
    };
    if (typeof document !== "undefined" && document?.hidden) {
      return this.storeEvent(event);
    } else {
      return this.sendEvent(event);
    }
  };
  sendEvent = async (event) => {
    const captureUrl = `${this.eventUrl}/e`;
    const payload = JSON.stringify(event);
    this.debug(`sending event:`, { url: captureUrl, event });
    if (this.isOffline()) {
      this.debug(`event not sent (offline mode):`, { event });
      return Promise.resolve();
    }
    try {
      const response = await fetch(captureUrl, {
        method: "POST",
        headers: {
          ...this.additionalHeaders ?? {},
          "Content-Type": "application/json;charset=UTF-8"
        },
        body: payload
      });
      this.debug(`event sent:`, {
        status: response.status,
        statusText: response.statusText
      });
    } catch (error) {
      console.error("Error sending Schematic event: ", error);
    }
    return Promise.resolve();
  };
  storeEvent = (event) => {
    this.eventQueue.push(event);
    return Promise.resolve();
  };
  /**
   * Websocket management
   */
  /**
   * If using websocket mode, close the connection when done.
   * In offline mode, this is a no-op.
   */
  cleanup = async () => {
    if (this.isOffline()) {
      this.debug("cleanup: skipped (offline mode)");
      return Promise.resolve();
    }
    if (this.conn) {
      try {
        const socket = await this.conn;
        socket.close();
      } catch (error) {
        console.error("Error during cleanup:", error);
      } finally {
        this.conn = null;
      }
    }
  };
  // Open a websocket connection
  wsConnect = () => {
    if (this.isOffline()) {
      this.debug("wsConnect: skipped (offline mode)");
      return Promise.reject(
        new Error("WebSocket connection skipped in offline mode")
      );
    }
    return new Promise((resolve, reject) => {
      const wsUrl = `${this.webSocketUrl}/flags/bootstrap?apiKey=${this.apiKey}`;
      this.debug(`connecting to WebSocket:`, wsUrl);
      const webSocket = new WebSocket(wsUrl);
      webSocket.onopen = () => {
        this.debug(`WebSocket connection opened`);
        resolve(webSocket);
      };
      webSocket.onerror = (error) => {
        this.debug(`WebSocket connection error:`, error);
        reject(error);
      };
      webSocket.onclose = () => {
        this.debug(`WebSocket connection closed`);
        this.conn = null;
      };
    });
  };
  // Send a message on the websocket indicating interest in a particular evaluation context
  // and wait for the initial set of flag values to be returned
  wsSendMessage = (socket, context) => {
    if (this.isOffline()) {
      this.debug("wsSendMessage: skipped (offline mode)");
      this.setIsPending(false);
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      if (contextString(context) == contextString(this.context)) {
        this.debug(`WebSocket context unchanged, skipping update`);
        return resolve(this.setIsPending(false));
      }
      this.debug(`WebSocket context updated:`, context);
      this.context = context;
      const sendMessage = () => {
        let resolved = false;
        const messageHandler = (event) => {
          const message = JSON.parse(event.data);
          this.debug(`WebSocket message received:`, message);
          if (!(contextString(context) in this.checks)) {
            this.checks[contextString(context)] = {};
          }
          (message.flags ?? []).forEach((flag) => {
            const flagCheck = CheckFlagReturnFromJSON(flag);
            const contextStr = contextString(context);
            if (this.checks[contextStr] === void 0) {
              this.checks[contextStr] = {};
            }
            this.checks[contextStr][flagCheck.flag] = flagCheck;
            this.debug(`WebSocket flag update:`, {
              flag: flagCheck.flag,
              value: flagCheck.value,
              flagCheck
            });
            if (typeof flagCheck.featureUsageEvent === "string") {
              this.updateFeatureUsageEventMap(flagCheck);
            }
            if (this.flagCheckListeners[flag.flag]?.size > 0 || this.flagValueListeners[flag.flag]?.size > 0) {
              this.submitFlagCheckEvent(flagCheck.flag, flagCheck, context);
            }
            this.notifyFlagCheckListeners(flag.flag, flagCheck);
            this.notifyFlagValueListeners(flag.flag, flagCheck.value);
          });
          this.flushContextDependentEventQueue();
          this.setIsPending(false);
          if (!resolved) {
            resolved = true;
            resolve();
          }
        };
        socket.addEventListener("message", messageHandler);
        const clientVersion = this.additionalHeaders["X-Schematic-Client-Version"] ?? `schematic-js@${version}`;
        const messagePayload = {
          apiKey: this.apiKey,
          clientVersion,
          data: context
        };
        this.debug(`WebSocket sending message:`, messagePayload);
        socket.send(JSON.stringify(messagePayload));
      };
      if (socket.readyState === WebSocket.OPEN) {
        this.debug(`WebSocket already open, sending message`);
        sendMessage();
      } else if (socket.readyState === WebSocket.CONNECTING) {
        this.debug(`WebSocket connecting, waiting for open to send message`);
        socket.addEventListener("open", sendMessage);
      } else {
        this.debug(`WebSocket is closed, cannot send message`);
        reject("WebSocket is not open or connecting");
      }
    });
  };
  /**
   * State management
   */
  // isPending state
  getIsPending = () => {
    return this.isPending;
  };
  addIsPendingListener = (listener) => {
    this.isPendingListeners.add(listener);
    return () => {
      this.isPendingListeners.delete(listener);
    };
  };
  setIsPending = (isPending) => {
    this.isPending = isPending;
    this.isPendingListeners.forEach(
      (listener) => notifyPendingListener(listener, isPending)
    );
  };
  // flag checks state
  getFlagCheck = (flagKey) => {
    const contextStr = contextString(this.context);
    const checks = this.checks[contextStr] ?? {};
    return checks[flagKey];
  };
  // flagValues state
  getFlagValue = (flagKey) => {
    const check = this.getFlagCheck(flagKey);
    return check?.value;
  };
  /** Register an event listener that will be notified with the boolean value for a given flag when this value changes */
  addFlagValueListener = (flagKey, listener) => {
    if (!(flagKey in this.flagValueListeners)) {
      this.flagValueListeners[flagKey] = /* @__PURE__ */ new Set();
    }
    this.flagValueListeners[flagKey].add(listener);
    return () => {
      this.flagValueListeners[flagKey].delete(listener);
    };
  };
  /** Register an event listener that will be notified with the full flag check response for a given flag whenever this value changes */
  addFlagCheckListener = (flagKey, listener) => {
    if (!(flagKey in this.flagCheckListeners)) {
      this.flagCheckListeners[flagKey] = /* @__PURE__ */ new Set();
    }
    this.flagCheckListeners[flagKey].add(listener);
    return () => {
      this.flagCheckListeners[flagKey].delete(listener);
    };
  };
  notifyFlagCheckListeners = (flagKey, check) => {
    const listeners = this.flagCheckListeners?.[flagKey] ?? [];
    if (listeners.size > 0) {
      this.debug(
        `Notifying ${listeners.size} flag check listeners for ${flagKey}`,
        check
      );
    }
    if (typeof check.featureUsageEvent === "string") {
      this.updateFeatureUsageEventMap(check);
    }
    listeners.forEach((listener) => notifyFlagCheckListener(listener, check));
  };
  /** Add or update a CheckFlagReturn in the featureUsageEventMap */
  updateFeatureUsageEventMap = (check) => {
    if (typeof check.featureUsageEvent !== "string") return;
    const eventName = check.featureUsageEvent;
    if (this.featureUsageEventMap[eventName] === void 0 || this.featureUsageEventMap[eventName] === null) {
      this.featureUsageEventMap[eventName] = {};
    }
    if (this.featureUsageEventMap[eventName] !== void 0) {
      this.featureUsageEventMap[eventName][check.flag] = check;
    }
    this.debug(
      `Updated featureUsageEventMap for event: ${eventName}, flag: ${check.flag}`,
      check
    );
  };
  notifyFlagValueListeners = (flagKey, value) => {
    const listeners = this.flagValueListeners?.[flagKey] ?? [];
    if (listeners.size > 0) {
      this.debug(
        `Notifying ${listeners.size} flag value listeners for ${flagKey}`,
        { value }
      );
    }
    listeners.forEach((listener) => notifyFlagValueListener(listener, value));
  };
};
var notifyPendingListener = (listener, value) => {
  if (listener.length > 0) {
    listener(value);
  } else {
    listener();
  }
};
var notifyFlagCheckListener = (listener, value) => {
  if (listener.length > 0) {
    listener(value);
  } else {
    listener();
  }
};
var notifyFlagValueListener = (listener, value) => {
  if (listener.length > 0) {
    listener(value);
  } else {
    listener();
  }
};

// src/context/schematic.tsx
var import_react = __toESM(require("react"));

// src/version.ts
var version2 = "1.2.6";

// src/context/schematic.tsx
var import_jsx_runtime = require("react/jsx-runtime");
var SchematicContext = (0, import_react.createContext)(
  null
);
var SchematicProvider = ({
  children,
  client: providedClient,
  publishableKey,
  ...clientOpts
}) => {
  const initialOptsRef = (0, import_react.useRef)({
    publishableKey,
    useWebSocket: clientOpts.useWebSocket ?? true,
    additionalHeaders: {
      "X-Schematic-Client-Version": `schematic-react@${version2}`
    },
    ...clientOpts
  });
  const client = (0, import_react.useMemo)(() => {
    if (providedClient) {
      return providedClient;
    }
    return new Schematic(initialOptsRef.current.publishableKey, {
      ...initialOptsRef.current
    });
  }, [providedClient]);
  (0, import_react.useEffect)(() => {
    return () => {
      if (!providedClient) {
        client.cleanup().catch((error) => {
          console.error("Error during cleanup:", error);
        });
      }
    };
  }, [client, providedClient]);
  const contextValue = (0, import_react.useMemo)(
    () => ({
      client
    }),
    [client]
  );
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SchematicContext.Provider, { value: contextValue, children });
};
var useSchematic = () => {
  const context = import_react.default.useContext(SchematicContext);
  if (context === null) {
    throw new Error("useSchematic must be used within a SchematicProvider");
  }
  return context;
};

// src/hooks/schematic.ts
var import_react2 = require("react");
var useSchematicClient = (opts) => {
  const schematic = useSchematic();
  const { client } = opts ?? {};
  return (0, import_react2.useMemo)(() => {
    if (client) {
      return client;
    }
    return schematic.client;
  }, [client, schematic.client]);
};
var useSchematicContext = (opts) => {
  const client = useSchematicClient(opts);
  return (0, import_react2.useMemo)(
    () => ({
      setContext: client.setContext.bind(client)
    }),
    [client]
  );
};
var useSchematicEvents = (opts) => {
  const client = useSchematicClient(opts);
  const track = (0, import_react2.useCallback)(
    (...args) => client.track(...args),
    [client]
  );
  const identify = (0, import_react2.useCallback)(
    (...args) => client.identify(...args),
    [client]
  );
  return (0, import_react2.useMemo)(() => ({ track, identify }), [track, identify]);
};
var useSchematicFlag = (key, opts) => {
  const client = useSchematicClient(opts);
  const fallback = opts?.fallback ?? false;
  const subscribe = (0, import_react2.useCallback)(
    (callback) => client.addFlagValueListener(key, callback),
    [client, key]
  );
  const getSnapshot = (0, import_react2.useCallback)(() => {
    const value = client.getFlagValue(key);
    return typeof value === "undefined" ? fallback : value;
  }, [client, key, fallback]);
  return (0, import_react2.useSyncExternalStore)(subscribe, getSnapshot, () => fallback);
};
var useSchematicEntitlement = (key, opts) => {
  const client = useSchematicClient(opts);
  const fallback = opts?.fallback ?? false;
  const fallbackCheck = (0, import_react2.useMemo)(
    () => ({
      flag: key,
      reason: "Fallback",
      value: fallback
    }),
    [key, fallback]
  );
  const subscribe = (0, import_react2.useCallback)(
    (callback) => client.addFlagCheckListener(key, callback),
    [client, key]
  );
  const getSnapshot = (0, import_react2.useCallback)(() => {
    const check = client.getFlagCheck(key);
    return check ?? fallbackCheck;
  }, [client, key, fallbackCheck]);
  return (0, import_react2.useSyncExternalStore)(subscribe, getSnapshot, () => fallbackCheck);
};
var useSchematicIsPending = (opts) => {
  const client = useSchematicClient(opts);
  const subscribe = (0, import_react2.useCallback)(
    (callback) => client.addIsPendingListener(callback),
    [client]
  );
  const getSnapshot = (0, import_react2.useCallback)(() => client.getIsPending(), [client]);
  return (0, import_react2.useSyncExternalStore)(subscribe, getSnapshot, () => true);
};
/*! Bundled license information:

@schematichq/schematic-js/dist/schematic.esm.js:
  (* @preserve *)
*/
